#ifndef TRISYCL_SYCL_DETAIL_PROGRAM_MANAGER_HPP
#define TRISYCL_SYCL_DETAIL_PROGRAM_MANAGER_HPP

#include "triSYCL/detail/singleton.hpp"
#include <iostream>
#include <string>
#include <fstream>

/** \file The minimum required functions for registering a binary
    using the triSYCL/Intel SYCL frontend, so that the compilation flow stays
    happy without too many alterations for now (the offloader needs these
    defined, even if they do nothing).

    The full implementations for this will require lifting existing
    triSYCL/Intel SYCL frontend code from triSYCL/Intel SYCL runtime's pi.h
    and program_manager.cpp/h files. There is a lot that is in the other SYCL
    runtime that's not here, so if you need functionality go look in the stated
    header and source files inside of: https://github.com/triSYCL/sycl

    This offloader and PI interface is unfortunately mostly a raw C Library and
    these functions and a lot of other functionality must be marked with extern
    C for now.

    Andrew point Gozillon at yahoo point com

    This file is distributed under the University of Illinois Open Source
    License. See LICENSE.TXT for details.
*/

// +++ Offload Wrapper Types, they must structurally match those defined by the
// clang-offload-wrapper if you use them but the names don't need to be
// equivalent they also all contain Intel SYCL pi.h equivalents
// (different naming convention) {

/// Offload entry point, possibly not required by us and it's not used by Intel
/// SYCL. It matches the structure __tgt_offload_entry generated by the
/// clang-offload-wrapper and is named _pi_offload_entry in the SYCL
/// PI interface
///
/// TODO: If this isn't required it's feasible to make it an opaque void type
/// like SYCL does so it remains compatible with OpenMP and the other SYCL
/// implementations e.g:
///
/// typedef void * __tgt_offload_entry;
///
struct __sycl_offload_entry {
  void *addr;
  char *name;
  size_t size;
  int32_t flags;
  int32_t reserved;
};

/// This struct is a record of the device binary information.
/// It must match the __tgt_device_image structure generated by the
/// clang-offload-wrapper tool when their Version fields match.
///
/// It's named pi_device_binary_struct in Intel SYCL's PI interface.
struct __sycl_device_image {
  /// version of this structure - for backward compatibility;
  /// all modifications which change order/type/offsets of existing fields
  /// should increment the version.
  uint16_t Version;
  /// the kind of offload model the image employs.
  uint8_t OffloadKind;
  /// format of the image data - SPIRV, LLVMIR bitcode,...
  uint8_t Format;
  /// null-terminated string representation of the device's target
  /// architecture
  const char *DeviceTargetSpec;
  /// a null-terminated string; target- and compiler-specific options
  /// which are suggested to use to "build" program at runtime
  const char *BuildOptions;
  /// Pointer to the manifest data start
  const unsigned char *ManifestStart;
  /// Pointer to the manifest data end
  const unsigned char *ManifestEnd;
  /// Pointer to the device binary image start
  const unsigned char *ImageStart;
  /// Pointer to the device binary image end
  const unsigned char *ImageEnd;
  /// the entry table
  __sycl_offload_entry *EntriesBegin;
  __sycl_offload_entry *EntriesEnd;
};

/// This must match the __tgt_bin_desc of the clang-offload-wrapper
///
/// In the Intel SYCL PI interface it's named pi_device_binaries_struct
struct __sycl_bin_desc {
  /// version of this structure - for backward compatibility;
  /// all modifications which change order/type/offsets of existing fields
  /// should increment the version.
  uint16_t Version;
  uint16_t NumDeviceImages;
  __sycl_device_image *DeviceImages;
  /// the offload entry table
  __sycl_offload_entry *HostEntriesBegin;
  __sycl_offload_entry *HostEntriesEnd;
};

// +++ }

// LOOK INTO OFFLOAD BUNDLER BEFORE COMMITTING IN ONE DIRECTION OR THE OTHER
//
// FIXME TOMORROW Need to think of a way to synch up the images to the tiles
// images technically don't have names associated with them.
// There is some ways I can probably do this, but I really do not want to alter
// the offload types if I can help it:
// 1) Create a new offload image type for AI Engine based on existing one,
//    that's only ever used for AI Engine offloading, but this may break
//    compatibility
// 2) Piggy back on one of the existing variables we don't use like BuildOptions
// 3) Create a new type of Register function that passes a string of image
//    to tile names..
namespace trisycl::detail {

/// singleton style program manager that's job is to hold all of the compiler
/// registered binaries and manage them. It's bare-bones and based on the Intel
/// SYCL implementation for now so it's quite feasible to deviate from it if
/// desired, the only requirement is that something stores the device_images
/// passed to the __tgt_register_lib function and that all of the used offload
/// wrapper types remain identical to the offload wrappers (name can be
/// different, but if the data layout is incorrect you're probably going to
/// have a bad time)
/// TODO: Look into:
///  1) Locks for Add Images
///  2) Proper image cleanup/release, there is none at the moment so this is
///     pretty much one big memory leak
///  3) Maybe make the structure names a little better than sycl_*
///  4) This could also just be part of the array.hpp class, but it could also
///     be more generic and used to store images for other types e.g arm32,
///     fpga etc.
class program_manager : public detail::singleton<program_manager> {
private:
  // TODO: Can probably get rid of this if we can rip all the data we need from
  // it when we run through
  std::unique_ptr<std::vector<__sycl_device_image*>> images;

  // A work-around to a work-around, the AI Engine runtime does some
  // manipulation of the elf binary in memory to work through a chess compiler
  // bug, so we need a copy of it as the original buffer containing each image
  // is read-only/const (not because of the const pointer defined in the
  // structure, but because the section inside the host binary that the device
  // binary is allocated in is a read-only section).
  std::vector<std::string> image_list;

public:
  // FIXME: We don't have an OpenCL style programming model where we just feed
  // it a kernel name for the kernels in the module how do we associate image
  // with tile?
  //
  /// This in theory loads all of the images for a module/translation unit and
  /// the images should in someway probably be correctly associated with a
  /// module
  void addImages(__sycl_bin_desc* desc) {
    // TODO: Probably needs a lock to not have data races when running on
    // multiple cores, Intel defines a global singleton lock based on C++
    // mutexs in it's Util.hpp class in the SYCL runtime and uses it as follows:
    // std::lock_guard<std::mutex> Guard(Sync::getGlobalLock());

    std::cout << "tried to register an image desc \n";
    std::cout << "number of device images in module: "
              << desc->NumDeviceImages << "\n";

    for (int i = 0; i < desc->NumDeviceImages; ++i) {
      __sycl_device_image* Img = &(desc->DeviceImages[i]);

      if (images == nullptr)
        images.reset(new std::vector<__sycl_device_image*>());

      std::cout << " Bin size : "
                << ((intptr_t)Img->ImageEnd - (intptr_t)Img->ImageStart)
                << "\n";

      image_dump(Img, "aie" + std::to_string(desc->NumDeviceImages) + ".elf");
      images->push_back(Img);
      image_list.push_back(std::string(Img->ImageStart, Img->ImageEnd));
    }
  }

  // Simple test function to dump an image to file
  void image_dump(__sycl_device_image * img, std::string filename) {
    std::ofstream F(filename, std::ios::binary);

    if (!F.is_open()) {
      std::cerr << "File for image dump could not be opened \n";
      return;
    }

    size_t ImgSize = static_cast<size_t>((intptr_t)img->ImageEnd - (intptr_t)img->ImageStart);
    F.write(reinterpret_cast<const char *>(img->ImageStart), ImgSize);

    F.close();
  }

  // A write-able copy of our binary image, mainly so the AI Engine runtime can
  // do some manipulation to workaround some chess problems.
  std::string get_image(unsigned int index) {
    return image_list.at(index);
  }

  /// The original read-only image section of the image stored in the fat-binary
  /// Only really useful for debugging or copying, directly casting off const
  /// and trying to manipulate this will result in a segfault
  const unsigned char* get_ro_image(unsigned int index) {
    std::cout << "Start Address: "
              << (void *)images.get()->data()[index]->ImageStart << "\n";

    std::cout << "End Address: "
              << (void *)images.get()->data()[index]->ImageEnd << "\n";


    std::cout << " Bin size from get_image: "
              << ((intptr_t)images.get()->at(index)->ImageEnd -
                 (intptr_t)images.get()->at(index)->ImageStart)
              << "\n";

    return images.get()->at(index)->ImageStart;
  }

};

}

extern "C" {

  // +++ Entry points referenced by the offload wrapper object {

  /// Executed as a part of current module's (.exe, .dll) static initialization.
  /// Registers device executable images with the runtime.
  /// Slightly modified variation of the Intel SYCL program_manager
  /// implementation
  /// TODO: Make barebones singleton program manager class that keeps track of
  /// our binaries...
  void __tgt_register_lib(__sycl_bin_desc* desc) {
    trisycl::detail::program_manager::instance()->addImages(desc);
  }

  /// Executed as a part of current module's (.exe, .dll) static
  /// de-initialization.
  /// Unregisters device executable images with the runtime.
  /// \TODO: Implement __tgt_unregister_lib for ACAP++ to enable binary
  /// management, although it isn't implemented in Intel SYCL as of the time of
  /// writing this.
  void __tgt_unregister_lib(__sycl_bin_desc* desc) {}

  // +++ }

}

/*
    # Some Emacs stuff:
    ### Local Variables:
    ### ispell-local-dictionary: "american"
    ### eval: (flyspell-prog-mode)
    ### End:
*/

#endif // TRISYCL_SYCL_DETAIL_PROGRAM_MANAGER_HPP
